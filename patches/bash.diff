			     BASH PATCH REPORT
			     =================

Bash-Release:	5.3
Patch-ID:	bash53-001

Bug-Reported-by:	John Sidles <jasidles@gmail.com>
Bug-Reference-ID:	<CAHOxHhRKa86FtRpsq-FBVciAxZ9kbo5PvfQBovBDXDFySbxj7A@mail.gmail.com>
Bug-Reference-URL:	https://lists.gnu.org/archive/html/bug-bash/2025-07/msg00035.html

Bug-Description:

In posix mode, `wait -n' with pid arguments does not restrict the set of
processes it considers to those arguments.

Patch (apply with `patch -p0'):

*** bash-5.3/jobs.c	Fri Mar  7 18:48:44 2025
--- jobs.c	Mon Jul 14 10:25:13 2025
***************
*** 3539,3543 ****
       one in bgpids. We can do this in posix mode because we'll remove any
       one we find from the table, preserving existing semantics. */
!   if (posixly_correct && (t = bgp_findone ()))
      {
        pid = t->pid;
--- 3539,3543 ----
       one in bgpids. We can do this in posix mode because we'll remove any
       one we find from the table, preserving existing semantics. */
!   if (posixly_correct && (flags & JWAIT_WAITING) == 0 && (t = bgp_findone ()))
      {
        pid = t->pid;

*** bash-5.3/patchlevel.h	2020-06-22 14:51:03.000000000 -0400
--- patchlevel.h	2020-10-01 11:01:28.000000000 -0400
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 0
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 1
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	5.3
Patch-ID:	bash53-002

Bug-Reported-by:	
Bug-Reference-ID:
Bug-Reference-URL:	https://savannah.gnu.org/bugs/?67326

Bug-Description:

There are too many differences in the various implementations of shm_open(2)
to rely on it for bash's use.

Patch (apply with `patch -p0'):

*** bash-5.3-patched/lib/sh/anonfile.c	Tue Jul  9 11:41:57 2024
--- lib/sh/anonfile.c	Thu Jul 17 11:03:23 2025
***************
*** 26,30 ****
  #include <bashtypes.h>
  
! #if defined (HAVE_MEMFD_CREATE) || defined (HAVE_SHM_OPEN) || defined (HAVE_SHM_MKSTEMP)
  #  include <sys/mman.h>
  #endif
--- 26,30 ----
  #include <bashtypes.h>
  
! #if defined (HAVE_MEMFD_CREATE) || defined (HAVE_SHM_MKSTEMP)
  #  include <sys/mman.h>
  #endif
***************
*** 42,57 ****
  #endif
  
! #if defined (HAVE_SHM_OPEN)
! #ifndef O_NOFOLLOW
! #  define O_NOFOLLOW 0
! #endif
! 
  static int
- anonshmunlink (const char *fn)
- {
-   return (shm_unlink (fn));
- }
- 
- static int
  anonshmopen (const char *name, int flags, char **fn)
  {
--- 42,47 ----
  #endif
  
! #if defined (HAVE_SHM_MKSTEMP)
  static int
  anonshmopen (const char *name, int flags, char **fn)
  {
***************
*** 63,95 ****
      *fn = 0;
  
- #if defined (HAVE_SHM_MKSTEMP)
    fname = savestring ("/shm-XXXXXXXXXX");
    fd = shm_mkstemp (fname);
    if (fd < 0)
-     free (fname);
- #endif
- 
-   if (fd < 0)
      {
-       fname = sh_mktmpname (name, flags);
-       fd = shm_open (fname, O_RDWR|O_CREAT|O_EXCL|O_NOFOLLOW, 0600);
-     }
- 
-   if (fd < 0)
-     {
        free (fname);
        return fd;
      }
  
-   if (shm_unlink (fname) < 0)
-     {
-       int o;
-       o = errno;
-       free (fname);
-       close (fd);
-       errno = o;
-       return -1;
-     }
- 
    if (fn)
      *fn = fname;
--- 53,64 ----
***************
*** 123,127 ****
    flag = (name && *name == '/') ? MT_TEMPLATE : MT_USETMPDIR;
  
! #if defined (HAVE_SHM_OPEN)
    fd = anonshmopen (name, flag, fn);
    if (fd >= 0)
--- 92,96 ----
    flag = (name && *name == '/') ? MT_TEMPLATE : MT_USETMPDIR;
  
! #if defined (HAVE_SHM_MKSTEMP)
    fd = anonshmopen (name, flag, fn);
    if (fd >= 0)

*** bash-5.3/patchlevel.h	2020-06-22 14:51:03.000000000 -0400
--- patchlevel.h	2020-10-01 11:01:28.000000000 -0400
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 1
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 2
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	5.3
Patch-ID:	bash53-003

Bug-Reported-by:	Isabella Bosia <izaberina@gmail.com>
Bug-Reference-ID:	<CAAZkfoJhQ1BJ7BGk3-ObctvCJJrW3rp_tWQXT=9rY7kGDvz4uw@mail.gmail.com>
Bug-Reference-URL:	https://lists.gnu.org/archive/html/bug-bash/2025-06/msg00173.html

Bug-Description:

Bash leaves internal quoting in place when expanding array subscripts
that appear inside array subscripts in an arithmetic context, causing
expansion failures.

Patch (apply with `patch -p0'):

*** bash-5.3-patched/subst.c	Sun May 18 15:00:13 2025
--- subst.c	Fri Jul 11 09:48:44 2025
***************
*** 3796,3802 ****
  #endif
  
! /* We don't perform process substitution in arithmetic expressions, so don't
!    bother checking for it. */
! #define ARITH_EXP_CHAR(s) (s == '$' || s == '`' || s == CTLESC || s == '~')
  
  /* If there are any characters in STRING that require full expansion,
--- 3796,3802 ----
  #endif
  
! /* We don't perform process substitution or tilde expansion in arithmetic
!    expressions, so don't bother checking for them. */
! #define ARITH_EXP_CHAR(s) (s == '$' || s == '`' || s == CTLESC)
  
  /* If there are any characters in STRING that require full expansion,
***************
*** 12216,12219 ****
--- 12216,12227 ----
  	      break;
  	    }
+ #if defined (ARRAY_VARS)
+ 	  /* The only special characters that matter here are []~, since those
+ 	     are backslash-quoted in expand_array_subscript but not dequoted
+ 	     by the statement following this one. */
+ 	  if ((quoted & Q_ARITH) && (c == LBRACK || c == RBRACK || c == '~'))
+ 	    ;		/* placeholder here */
+ 	  else
+ #endif
  	  if (((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) || dquote) && (sh_syntaxtab[c] & CBSDQUOTE) == 0)
  	    *r++ = '\\';
*** bash-5.3/tests/quotearray.right	Thu Nov 10 10:39:56 2022
--- tests/quotearray.right	Thu Jul 10 15:40:27 2025
***************
*** 45,49 ****
  0
  0
! ./quotearray1.sub: line 68: 0\],b\[1: arithmetic syntax error: invalid arithmetic operator (error token is "\],b\[1")
  declare -a array
  0
--- 45,49 ----
  0
  0
! ./quotearray1.sub: line 68: 0],b[1: arithmetic syntax error: invalid arithmetic operator (error token is "],b[1")
  declare -a array
  0
*** bash-5.3/patchlevel.h	2020-06-22 14:51:03.000000000 -0400
--- patchlevel.h	2020-10-01 11:01:28.000000000 -0400
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 2
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 3
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	5.3
Patch-ID:	bash53-004

Bug-Reported-by:	Emanuele Torre <torreemanuele6@gmail.com>
Bug-Reference-ID:	<aHKS0uA8Sf_vMT25@ntoo>
Bug-Reference-URL:	https://lists.gnu.org/archive/html/bug-bash/2025-07/msg00031.html

Bug-Description:

The Linux kernel reports incorrect sizes for files in /sys/block/*/uevent,
leading bash to report a read error when the byte count does not agree
with the file size from fstat(2).

Patch (apply with `patch -p0'):

*** bash-5.3-patched/builtins/evalfile.c	Fri Sep  6 15:42:40 2024
--- builtins/evalfile.c	Fri Sep 12 11:38:57 2025
***************
*** 161,166 ****
--- 161,168 ----
        if (nr >= 0)
  	string[nr] = '\0';
+ #if 0
        if (nr != file_size)
  	nr = -1;		/* XXX - didn't get the whole file */
+ #endif
      }
    else

*** bash-5.3/patchlevel.h	2020-06-22 14:51:03.000000000 -0400
--- patchlevel.h	2020-10-01 11:01:28.000000000 -0400
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 3
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 4
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	5.3
Patch-ID:	bash53-005

Bug-Reported-by:	chet.ramey@case.edu
Bug-Reference-ID:
Bug-Reference-URL:

Bug-Description:

Restoring the default disposition in a subshell for a signal bash treats
specially can cause a crash.

Patch (apply with `patch -p0'):

*** bash-5.3-patched/trap.c	Thu Dec 19 11:35:49 2024
--- trap.c	Fri Nov  7 11:23:31 2025
***************
*** 965,968 ****
--- 965,969 ----
        set_signal_handler (sig, SIG_DFL);
        change_signal (sig, (char *)DEFAULT_SIG);
+       sigmodes[sig] &= ~SIG_TRAPPED;	/* no longer trapped */
        return;
      }
*** bash-5.3/patchlevel.h	2020-06-22 14:51:03.000000000 -0400
--- patchlevel.h	2020-10-01 11:01:28.000000000 -0400
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 4
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 5
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	5.3
Patch-ID:	bash53-006

Bug-Reported-by:	Duncan Roe <duncan_roe@optusnet.com.au>
Bug-Reference-ID:	<aL0p/3BQeCLc6krz@dimstar.local.net>
Bug-Reference-URL:	https://lists.gnu.org/archive/html/bug-bash/2025-09/msg00053.html

Bug-Description:

When `globasciiranges' is enabled, glob patterns with ranges in bracket
expressions can produce incorrect matches for character ranges whose
start and end are non-ascii characters.

Patch (apply with `patch -p0'):

*** bash-5.3-patched/lib/glob/smatch.c	Mon May 29 14:15:17 2023
--- lib/glob/smatch.c	Mon Sep  8 12:54:59 2025
***************
*** 391,395 ****
      return 0;
  
!   if (forcecoll == 0 && glob_asciirange && c1 <= UCHAR_MAX && c2 <= UCHAR_MAX)
      return ((int)(c1 - c2));
  
--- 391,395 ----
      return 0;
  
!   if (forcecoll == 0 && glob_asciirange)
      return ((int)(c1 - c2));
  
*** bash-5.3/patchlevel.h	2020-06-22 14:51:03.000000000 -0400
--- patchlevel.h	2020-10-01 11:01:28.000000000 -0400
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 5
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 6
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	5.3
Patch-ID:	bash53-007

Bug-Reported-by:	jdhedden@gmail.com
Bug-Reference-ID:	<689ac876.050a0220.334a3f.30fb@mx.google.com>
Bug-Reference-URL:	

Bug-Description:

No-fork command substitutions can perform redirections that act on the
enclosing command as well.

Patch (apply with `patch -p0'):

*** bash-5.3-patched/subst.c	Fri Jul 25 08:53:25 2025
--- subst.c	Tue Aug 12 15:41:01 2025
***************
*** 207,210 ****
--- 207,212 ----
  extern int extended_quote;
  
+ extern REDIRECT *exec_redirection_undo_list, *redirection_undo_list;
+ 
  #if !defined (HAVE_WCSDUP) && defined (HANDLE_MULTIBYTE)
  extern wchar_t *wcsdup (const wchar_t *);
***************
*** 7001,7004 ****
--- 7003,7011 ----
      }
  #endif
+ 
+   unwind_protect_pointer (redirection_undo_list);
+   redirection_undo_list = NULL;
+   unwind_protect_pointer (exec_redirection_undo_list);
+   exec_redirection_undo_list = NULL;
    
    subst_assign_varlist = 0;

*** bash-5.3/patchlevel.h	2020-06-22 14:51:03.000000000 -0400
--- patchlevel.h	2020-10-01 11:01:28.000000000 -0400
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 6
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 7
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	5.3
Patch-ID:	bash53-008

Bug-Reported-by:	Grisha Levit <grishalevit@gmail.com>
Bug-Reference-ID:	<20251022174207.10518-1-grishalevit@gmail.com>
Bug-Reference-URL:	https://lists.gnu.org/archive/html/bug-bash/2025-10/msg00145.html

Bug-Description:

Bash tries to consume entire multibyte characters when looking for backslash
escapes in $'...' strings, and treats too many characters as potentially
beginning a multibyte character in UTF-8 locales. Being more selective about
when to call mbrtowc() can lead to optimized string processing and script
speedups. This patch also handles the unlikely situation of a locale
encoding null wide characters with non-null bytes.

Patch (apply with `patch -p0'):

*** bash-5.3-patched/lib/sh/strtrans.c	Fri Oct 13 11:57:46 2023
--- lib/sh/strtrans.c	Mon Oct 27 14:30:35 2025
***************
*** 56,60 ****
    unsigned long v;
    size_t clen;
!   int mb_cur_max;
  #if defined (HANDLE_MULTIBYTE)
    wchar_t wc;
--- 56,60 ----
    unsigned long v;
    size_t clen;
!   size_t mb_cur_max;
  #if defined (HANDLE_MULTIBYTE)
    wchar_t wc;
***************
*** 64,68 ****
      return ((char *)0);
  
!   mb_cur_max = MB_CUR_MAX;
  #if defined (HANDLE_MULTIBYTE)
    temp = 4*len + 4;
--- 64,68 ----
      return ((char *)0);
  
!   mb_cur_max = locale_mb_cur_max;
  #if defined (HANDLE_MULTIBYTE)
    temp = 4*len + 4;
***************
*** 80,87 ****
  	  clen = 1;
  #if defined (HANDLE_MULTIBYTE)
! 	  if ((locale_utf8locale && (c & 0x80)) ||
! 	      (locale_utf8locale == 0 && mb_cur_max > 0 && is_basic (c) == 0))
  	    {
  	      clen = mbrtowc (&wc, s - 1, mb_cur_max, 0);
  	      if (MB_INVALIDCH (clen))
  		clen = 1;
--- 80,91 ----
  	  clen = 1;
  #if defined (HANDLE_MULTIBYTE)
! 	  /* We read an entire multibyte character at a time if we are in a
! 	     locale where a backslash can possibly appear as part of a
! 	     multibyte character. UTF-8 encodings prohibit this. */
! 	  if (locale_utf8locale == 0 && mb_cur_max > 1 && is_basic (c) == 0)
  	    {
  	      clen = mbrtowc (&wc, s - 1, mb_cur_max, 0);
+ 	      if (MB_NULLWCH (clen))
+ 		break;			/* it apparently can happen */
  	      if (MB_INVALIDCH (clen))
  		clen = 1;
***************
*** 228,237 ****
    char *r, *ret;
    const char  *s;
-   size_t l, rsize;
    unsigned char c;
    size_t clen;
    int b;
- #if defined (HANDLE_MULTIBYTE)
    wchar_t wc;
  #endif
  
--- 232,241 ----
    char *r, *ret;
    const char  *s;
    unsigned char c;
+ #if defined (HANDLE_MULTIBYTE)
    size_t clen;
    int b;
    wchar_t wc;
+   DECLARE_MBSTATE;
  #endif
  
***************
*** 239,245 ****
      return ((char *)0);
  
!   l = strlen (str);
!   rsize = 4 * l + 4;
!   r = ret = (char *)xmalloc (rsize);
  
    *r++ = '$';
--- 243,247 ----
      return ((char *)0);
  
!   r = ret = (char *)xmalloc (4 * strlen (str) + 4);
  
    *r++ = '$';
***************
*** 248,255 ****
    for (s = str; c = *s; s++)
      {
-       b = 1;		/* 1 == add backslash; 0 == no backslash */
-       l = 1;
-       clen = 1;
- 
        switch (c)
  	{
--- 250,253 ----
***************
*** 267,303 ****
  	default:
  #if defined (HANDLE_MULTIBYTE)
! 	  b = is_basic (c);
! 	  /* XXX - clen comparison to 0 is dicey */
! 	  if ((b == 0 && ((clen = mbrtowc (&wc, s, MB_CUR_MAX, 0)) < 0 || MB_INVALIDCH (clen) || iswprint (wc) == 0)) ||
! 	      (b == 1 && ISPRINT (c) == 0))
! #else
! 	  if (ISPRINT (c) == 0)
! #endif
  	    {
! 	      *r++ = '\\';
! 	      *r++ = TOCHAR ((c >> 6) & 07);
! 	      *r++ = TOCHAR ((c >> 3) & 07);
! 	      *r++ = TOCHAR (c & 07);
! 	      continue;
  	    }
! 	  l = 0;
! 	  break;
! 	}
!       if (b == 0 && clen == 0)
! 	break;
  
!       if (l)
! 	*r++ = '\\';
! 
!       if (clen == 1)
! 	*r++ = c;
!       else
! 	{
! 	  for (b = 0; b < (int)clen; b++)
! 	    *r++ = (unsigned char)s[b];
! 	  s += clen - 1;	/* -1 because of the increment above */
  	}
      }
  
    *r++ = '\'';
    *r = '\0';
--- 265,304 ----
  	default:
  #if defined (HANDLE_MULTIBYTE)
! 	  if ((locale_utf8locale && (c & 0x80)) ||
! 	      (locale_utf8locale == 0 && locale_mb_cur_max > 1 && is_basic (c) == 0))
  	    {
! 	      clen = mbrtowc (&wc, s, locale_mb_cur_max, &state);
! 	      if (MB_NULLWCH (clen))
! 		goto quote_end;
! 	      if (MB_INVALIDCH (clen))
! 		INITIALIZE_MBSTATE;
! 	      else if (iswprint (wc))
! 		{
! 		  for (b = 0; b < (int)clen; b++)
! 		    *r++ = (unsigned char)s[b];
! 		  s += clen - 1;	/* -1 because of the increment above */
! 		  continue;
! 		}
  	    }
! 	  else
! #endif
! 	    if (ISPRINT (c))
! 	      {
! 		*r++ = c;
! 		continue;
! 	      }
  
! 	  *r++ = '\\';
! 	  *r++ = TOCHAR ((c >> 6) & 07);
! 	  *r++ = TOCHAR ((c >> 3) & 07);
! 	  *r++ = TOCHAR (c & 07);
! 	  continue;
  	}
+ 
+       *r++ = '\\';
+       *r++ = c;
      }
  
+ quote_end:
    *r++ = '\'';
    *r = '\0';
***************
*** 349,353 ****
      {
  #if defined (HANDLE_MULTIBYTE)
!       if (is_basic (c) == 0)
  	return (ansic_wshouldquote (s));
  #endif
--- 350,355 ----
      {
  #if defined (HANDLE_MULTIBYTE)
!       if ((locale_utf8locale && (c & 0x80)) ||
! 	  (locale_utf8locale == 0 && locale_mb_cur_max > 1 && is_basic (c) == 0))
  	return (ansic_wshouldquote (s));
  #endif

*** bash-5.3/patchlevel.h	2020-06-22 14:51:03.000000000 -0400
--- patchlevel.h	2020-10-01 11:01:28.000000000 -0400
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 7
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 8
  
  #endif /* _PATCHLEVEL_H_ */
